"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ulid = exports.replaceCharAt = exports.randomChar = exports.monotonicFactory = exports.incrementBase32 = exports.encodeTime = exports.encodeRandom = exports.detectPRNG = exports.decodeTime = void 0;
var layerr_1 = require("layerr");
// These values should NEVER change. The values are precisely for
// generating ULIDs.
var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"; // Crockford's Base32
var ENCODING_LEN = ENCODING.length;
var TIME_MAX = Math.pow(2, 48) - 1;
var TIME_LEN = 10;
var RANDOM_LEN = 16;
var ERROR_INFO = Object.freeze({
    source: "ulid"
});
function decodeTime(id) {
    if (id.length !== TIME_LEN + RANDOM_LEN) {
        throw new layerr_1.Layerr({
            info: __assign({ code: "DEC_TIME_MALFORMED" }, ERROR_INFO)
        }, "Malformed ULID");
    }
    var time = id
        .substr(0, TIME_LEN)
        .split("")
        .reverse()
        .reduce(function (carry, char, index) {
        var encodingIndex = ENCODING.indexOf(char);
        if (encodingIndex === -1) {
            throw new layerr_1.Layerr({
                info: __assign({ code: "DEC_TIME_CHAR" }, ERROR_INFO)
            }, "Time decode error: Invalid character: " + char);
        }
        return (carry += encodingIndex * Math.pow(ENCODING_LEN, index));
    }, 0);
    if (time > TIME_MAX) {
        throw new layerr_1.Layerr({
            info: __assign({ code: "DEC_TIME_CHAR" }, ERROR_INFO)
        }, "Malformed ULID: timestamp too large: " + time);
    }
    return time;
}
exports.decodeTime = decodeTime;
function detectPRNG(root) {
    var rootLookup = root || detectRoot();
    var globalCrypto = (rootLookup && (rootLookup.crypto || rootLookup.msCrypto)) ||
        (typeof crypto !== "undefined" ? crypto : null);
    if (typeof (globalCrypto === null || globalCrypto === void 0 ? void 0 : globalCrypto.getRandomValues) === "function") {
        return function () {
            var buffer = new Uint8Array(1);
            globalCrypto.getRandomValues(buffer);
            return buffer[0] / 0xff;
        };
    }
    else if (typeof (globalCrypto === null || globalCrypto === void 0 ? void 0 : globalCrypto.randomBytes) === "function") {
        return function () { return globalCrypto.randomBytes(1).readUInt8() / 0xff; };
    }
    else {
        try {
            var nodeCrypto_1 = require("crypto");
            return function () { return nodeCrypto_1.randomBytes(1).readUInt8() / 0xff; };
        }
        catch (e) { }
    }
    throw new layerr_1.Layerr({
        info: __assign({ code: "PRNG_DETECT" }, ERROR_INFO)
    }, "Failed to find a reliable PRNG");
}
exports.detectPRNG = detectPRNG;
function detectRoot() {
    if (inWebWorker())
        return self;
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    return null;
}
function encodeRandom(len, prng) {
    var str = "";
    for (; len > 0; len--) {
        str = randomChar(prng) + str;
    }
    return str;
}
exports.encodeRandom = encodeRandom;
function encodeTime(now, len) {
    if (isNaN(now)) {
        throw new layerr_1.Layerr({
            info: __assign({ code: "ENC_TIME_NAN" }, ERROR_INFO)
        }, "Time must be a number: " + now);
    }
    else if (now > TIME_MAX) {
        throw new layerr_1.Layerr({
            info: __assign({ code: "ENC_TIME_SIZE_EXCEED" }, ERROR_INFO)
        }, "Cannot encode a time larger than " + TIME_MAX + ": " + now);
    }
    else if (now < 0) {
        throw new layerr_1.Layerr({
            info: __assign({ code: "ENC_TIME_NEG" }, ERROR_INFO)
        }, "Time must be positive: " + now);
    }
    else if (Number.isInteger(now) === false) {
        throw new layerr_1.Layerr({
            info: __assign({ code: "ENC_TIME_TYPE" }, ERROR_INFO)
        }, "Time must be an integer: " + now);
    }
    var mod, str = "";
    for (var currentLen = len; currentLen > 0; currentLen--) {
        mod = now % ENCODING_LEN;
        str = ENCODING.charAt(mod) + str;
        now = (now - mod) / ENCODING_LEN;
    }
    return str;
}
exports.encodeTime = encodeTime;
function incrementBase32(str) {
    var done = undefined, index = str.length, char, charIndex, output = str;
    var maxCharIndex = ENCODING_LEN - 1;
    while (!done && index-- >= 0) {
        char = output[index];
        charIndex = ENCODING.indexOf(char);
        if (charIndex === -1) {
            throw new layerr_1.Layerr({
                info: __assign({ code: "B32_INC_ENC" }, ERROR_INFO)
            }, "Incorrectly encoded string");
        }
        if (charIndex === maxCharIndex) {
            output = replaceCharAt(output, index, ENCODING[0]);
            continue;
        }
        done = replaceCharAt(output, index, ENCODING[charIndex + 1]);
    }
    if (typeof done === "string") {
        return done;
    }
    throw new layerr_1.Layerr({
        info: __assign({ code: "B32_INC_INVALID" }, ERROR_INFO)
    }, "Failed incrementing string");
}
exports.incrementBase32 = incrementBase32;
function inWebWorker() {
    // @ts-ignore
    return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
function monotonicFactory(prng) {
    var currentPRNG = prng || detectPRNG();
    var lastTime = 0, lastRandom;
    return function _ulid(seedTime) {
        var seed = isNaN(seedTime) ? Date.now() : seedTime;
        if (seed <= lastTime) {
            var incrementedRandom = (lastRandom = incrementBase32(lastRandom));
            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;
        }
        lastTime = seed;
        var newRandom = (lastRandom = encodeRandom(RANDOM_LEN, currentPRNG));
        return encodeTime(seed, TIME_LEN) + newRandom;
    };
}
exports.monotonicFactory = monotonicFactory;
function randomChar(prng) {
    var rand = Math.floor(prng() * ENCODING_LEN);
    if (rand === ENCODING_LEN) {
        rand = ENCODING_LEN - 1;
    }
    return ENCODING.charAt(rand);
}
exports.randomChar = randomChar;
function replaceCharAt(str, index, char) {
    if (index > str.length - 1) {
        return str;
    }
    return str.substr(0, index) + char + str.substr(index + 1);
}
exports.replaceCharAt = replaceCharAt;
function ulid(seedTime, prng) {
    var currentPRNG = prng || detectPRNG();
    var seed = isNaN(seedTime) ? Date.now() : seedTime;
    return encodeTime(seed, TIME_LEN) + encodeRandom(RANDOM_LEN, currentPRNG);
}
exports.ulid = ulid;
